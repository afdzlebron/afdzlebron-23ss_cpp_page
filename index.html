<!DOCTYPE html>

<html lang="deu">

<head>
  <meta charset="utf-8" />
  <title>Programmieren in C++</title>
  <!-- icon -->
  <!-- <link rel="icon" href="./img/attent.ico" /> -->
  <!-- css -->
  <link href="css/style.css" rel="stylesheet" type="text/css" />
  <!-- Webfont -->
  <link href="https://fonts.gstatic.com" rel="preconnect" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap" rel="stylesheet" />
  <!-- Font Awesome -->
  <link href="./fontawesome/css/all.css" rel="stylesheet" />
</head>

<body>
  <header id="top">
    <nav>
      <a href="#">Home</a>
      <a href="blatt01.html">blatt01</a>
      <a href="blatt02.html">blatt02</a>
      <a href="blatt03.html">blatt03</a>
      <a href="blatt04.html">blatt04</a>
      <a href="blatt05.html">blatt05</a>
      <a href="blatt06.html">blatt06</a>
      <a href="blatt07.html">blatt07</a>
      <a href="blatt08.html">blatt08</a>
      <a href="blatt09.html">blatt09</a>
      <a href="blatt10.html">blatt10</a>
      <a href="open.html">Open</a>
      <a href="cml.html">CML</a>
    </nav>
    <h1><i class="fa fa-brain"></i> Programmieren in C++< </h1>
  </header>

  <main>
    Programmieren in C++

    <pre>


Projekt: Übersicht


(1) Einführung In das Problem:
Wir interessieren uns für die Paarbildungsmethode. 
Bei dieser Methode geht es darum, ein Programm mit vielen Optionen zu testen, wobei möglichst wenige Konfigurationen verwendet werden.
Leider gibt es meistens zu viele Optionen, um alle testen zu können: 
Der SAT-Solver Lingeling von Armin Biere hat mehr Optionen als Atome im Universum (weil es Parameter gibt, die Integer oder sogar Gleitkommazahlen als Wert annehmen können).
Da es einfach zu viele Konfigurationen gibt, interessieren wir uns nur dafür, dass zwei Optionen (die kombiniert werden können) auch einmal gemeinsam getestet werden können - unabhängig von den anderen Optionen. 
Solch eine Kombination von zwei Optionen mit jeweils einem Wert ist ein Paar. 
Eine Kombination von 10 Optionen ermöglicht es also, `9 + 8 + 7 + ... + 1` = `55` Paare zu testen. 
Es reicht jedoch nicht aus, einfach alle Optionen aufzulisten, da es auch Optionen gibt, die nicht miteinander kompatibel sind.
Damit das alles klarer wird werden wir uns jetzt ein Beispiel ansehen (Wikipedia Beispiel mit anderen Namen). 
Es gibt 3 Auswahlmöglichkeiten:

   Prozessor Intel oder AMD

   RAM Geschwindigkeit 5000MT/s, 6000MT/s, und 7000MT/s

   Bildschirm 1K, 2K, 4K, 8K

Es gibt `2 * 3 + 2 * 4 + 3 * 4` Paare (jeden Prozessor mit jeder Geschwindigkeit, jeden Prozessor mit jedem Bildschirm, und jede Geschwindigkeit mit jedem Bildschirm).
Mit der Paarbildungsmethode reicht es sich für folgende 12 Modelle zu interessieren, anstatt alle
26 Modelle:

```
Prozessor   RAM     Bildschirm
   Intel       7          1K
   Intel       5          8K
   AMD         5          4K
   AMD         6          8K
   Intel       6          4K
   AMD         6          1K
   AMD         5          1K
   AMD         7          2K
   Intel       6          2K
   Intel       7          8K
   AMD         7          4K
   Intel       5          2K
```
Eigentlich ist es noch etwas komplizierter, weil es Optionen gibt, die nicht kompatibel sind. Zum
Beispiel unterstützt AMD nur 5000MT/s und stürzt bei höheren Geschwindigkeiten ab. Es ist
auch nicht möglich, gleichzeitig Intel mit dem langsamen Speicher und dem 8K-Bildschirm zu
wählen.


(2) Die Darstellung:
Um unser Problem darzustellen, nutzen wir einfach CSV-Dateien. Eine CSV-Datei (comma separated value) bedeutet einfach, das der Text mit Komma separiert wird.
Für die Optionen (der Dateiname sollte mit ``.options`` enden) schreiben wir einfach jede Option
mit allen möglichen Werten auf:
```
Prozessor,Intel,AMD
RAM,5,6,7
Bildschirm,1,2,4,8
```

Wir erlauben ASCII, aber kein UTF-16. 
Das muss jedoch nicht nachgeprüft werden. 
Sie können einfach char nutzen. Wir erlauben auch Leerzeichen in den Namen.
Dann können wir die Optionen aufschreiben, die nicht gleichzeitig wahr sein sollen (Der Dateiname sollte mit ``.constraints`` enden).

```
Prozessor,AMD,RAM,6
Prozessor,AMD,RAM,7
Prozessor,Intel,RAM,5,Bildschirm,8
```

Jeder Zeile bedeuted also, dass mindestens eine Option anders gesetzt werden muss.
Lösungen (Modelle) schreiben wir wieder als CSV. 
Dabei müssen natürlich alle Optionen gesetzt werden und die Werte müssen mit den Constraints kompatibel sein. 
Eine mögliche Datei könnte beispielsweise wie folgt aussehen (der Dateiname sollte mit `.models` enden):

```
Prozessor,Intel,RAM,5,Bildschirm,2
Prozessor,Intel,RAM,6,Bildschirm,2
RAM,7,Prozessor,Intel,Bildschirm,1
Prozessor,Intel,RAM,7,Bildschirm,4
Prozessor,AMD,RAM,5,Bildschirm,4
RAM,5,Prozessor,AMD,Bildschirm,8
RAM,5,Prozessor,AMD,Bildschirm,1
Prozessor,Intel,RAM,6,Bildschirm,4
Bildschirm,2,Prozessor,AMD,RAM,5
Prozessor,Intel,RAM,6,Bildschirm,8
```

Das Ziel dieses Projekts ist es, eine Approximation aller Modelle zu produzieren (alle Modelle sollen korrekt sein, aber es könnten einige fehlen). 
Da es sich um einen probabilistischen Ansatz handelt, könnten hier Lösungen fehlen (direkt aus dem Solver in meiner Lösung).

```
c   there are 3 uncovered pairs
c   RAM->6 && Prozessor->AMD
c   Bildschirm->4 && RAM->6
c   Bildschirm->8 && RAM->6
```
Die Paare 2 und 3 könnten mit dem Intel Prozessor bedeckt werden, aber das wurde nicht generiert.


(3) Ziele:
Sie müssen folgendes implementieren im C++:

->Parser und pretty-printer (Blatt 11) die Datein ``.options`` und ``.constraints`` einlesen und wieder ausgeben.

->Solver (Pflicht, Blatt 12) Die Datei .models soll mit möglichen Modellen gefüllt werden. 
Die einfachste korrekte Implementierung produziert keine Modelle, aber das gibt auch keine Punkte.

->Checker (Variante A, Blatt 12) Er liest die Dateien ``.options``, ``.constraints`` und `.models` ein und prüfe, ob alle gefundenen Modelle auch die Constraints erfüllen.

->Fuzzer (Variante B, Blatt 12) Random Dateien ``.options`` und ``.constraints`` generieren. Das Ziel ist es diese Probleme zu lösen und nach Bugs zu suchen.

Die Varianten bauen sehr stark auf das Lösen auf. Sie können also in beliebiger Reihenfolge implementiert werden.

Sie müssen sowohl Variante A als auch B machen.

Um beim Testen zu helfen, gibt es zwei binäre Dateien zur Verfügung:

    • einen Fuzzer namens `crippled-fuzzer`, der jedoch nur 16 unterschiedliche Programme generieren kann. 
      Er generiert auch nur Optionen, die einen Buchstaben lang sind, und die Werte sind entweder 0 oder 1.

    • einen Checker namens `russian-roulette-checker`, der zwar überprüft, aber oft mit s UNKNOWN antwortet.


(4):

(4.1)    Lösen von Problem:

Um das Problem zu lösen, müssen Sie (möglichst alle) Modelle generieren. 
Um dies zu tun, werden wir zufällig generierte Konfigurationen nutzen.
Dafür müssen Sie zuerst alle möglichen Paare generieren.
Wenn Sie dann eine Konfiguration produzieren wollen, fangen Sie mit der leeren Konfiguration an und erweitern sie. 
Dafür füllen Sie die Konfiguration mit einer Option. 
Da es notwendig sein kann, auch einen Wert zu nehmen, der bereits gesehen worden ist, setzen Sie mit geringer Wahrscheinlichkeit eine Option unabhängig von den noch verbleibenden Paaren. 
Mit hoher Wahrscheinlichkeit nehmen Sie aber ein Paar, das noch nicht abgedeckt ist.
Wenn Sie dann eine vollständige Konfiguration generiert haben, müssen Sie testen, ob sie mit den Constraints kompatibel ist. Wenn dies der Fall ist, haben Sie ein neues Modell gefunden und können alle Paare als abgedeckt markieren.
Nach 1000 Konfigurationen, die die Constraints nicht erfüllen, sind wir dann fertig (auch wenn
es vielleicht noch mehr Möglichkeiten gibt).

`Tabelle 1: Return Codes`: 
```
Return code | Sinn
______________________________
    0       | Keine Fehler
   10       | Datei konnte nicht geöffnet werden
   20       | Keine valide Eingabedatei (z.B., nicht deklarierte Option)
   30       | Anderer Fehler
```


In Tabelle 1 finden Sie die genauen Rückgabewerte, die aus dem Hauptprogramm kommen sollen, je nachdem, was passiert ist.


(4.2)    Checker:

Ein Checker ist ein Program, der die 3 Datein (Optionen, Constraints, und Modelle) nimmt und immer schaut ob:

  1. in jedem Model alle Optionen genau einmal angegeben werden

  2. jedes Model auch alle Constraints erfüllt

  3. In den Modellen und in den Constraint gibt es nur Optionen und Werte aus der `.options`
     Datei.

  4. invalide Input Dateien (fehlende Werte zum Beispiel)

Nicht zulässig sind also Konfiguration und Constraints:
   wo Optionen erfunden wurden (Punkt 3 oben),
   wo Werte erfunden wurden (Punkt 3 oben), 
   wo nicht alle Option gesetzt sind (Punkt 1 oben), 
   oder Modelle die nicht die Constraints erfüllen (Punkt 2 oben).

Nicht relevant für den Checker ist die Reihenfolge der Optionen oder Modelle die doppelt auftauchen.
In Tabelle 2 stehen erneut die unterschiedlichen Return-Codes und das Verhalten, das das Programm haben sollte.
Um das Problem möglichst genau zu lösen, sehen Sie sich bitte die Vorlesung zum Lösen des
SAT-Problems im nächsten Sommersemester an. Beachten Sie, dass auch fleißig implementiert wird.
Eigentlich würden wir hier auch einen verifizierten Checker haben wollen. 
Es ist jedoch noch offen, ob es eine Isabelle-Vorlesung im nächsten Sommersemester gibt.

`Tabelle 1: Return Codes`:
```
             Return code |  Sinn
             -----------------------------------------------------------------------------
                  0      |  Keine Fehler, korrekt gecheckt. Es sollte auch `s` `VERIFIED` auf `stdout` stehen (in C++, `std::cout <<`).
                  10     |  Nicht-mögliche `.options`.
                  20     |  Nicht-mögliche `.constraints`.
                  30     |  Fehler in `.models`. In diesem Fall sollte auf `stderr` (in C++, `std::cerr <<` genau stehen welches `Models` nicht valide ist und warum). Es sollte auch s `UNVERIFIED` auf `stdout`..
                  40     |  Anderer Fehler (gibt `s` `UNKNOWN` aus: das sollte Ihr Checker nicht machen).

```

4.3    Fuzzer

Ein Fuzzer ist ein Programm, das zufällige Optionen, Werte und Constraints generiert, um valide
Dateien zu erzeugen:

  1. Alle Optionen und Werte aus den Constraints sind auch in der `.options` Datei enthalten.
                              

Blatt 11

Aufgabe 1:

Als ersten Schritt zur Realisierung schreiben Sie bitte folgenden Code:

  1. Schreiben Sie alle benötigten .hpp Dateien mit allen Klassen, Methoden und Membervariablen, die Ihrer Meinung nach für Ihr Programm am Ende benötigt werden. Schreiben Sie zu jeder Klasse, Methode oder Membervariablen einen (kurzen aber aussagekräftigen) erklärenden Kommentar.

  2. Schreiben Sie den Parser für die `.options` und `.constraints`. Der Parser soll die Datenstrukturen füllen. Für den Parser dürfen Sie nur `get(char)` (aus `std::istream`) (oder die
     C Version `getc`). Sie dürfen also nicht direkt strings einlesen.

  3. Schreiben Sie eine Funktion, die die Optionen und die Constraints wieder ausgibt.  Das ist ein Pretty-printer. Sie soll also eine zweite `.options` Datei und eine zweite `.constraints` ausgeben, die identisch zur Originaldatei (bis auf der Reihenfolge) ist. Ein Aufruf sollte in etwa so aussehen: `mein-super-program` `a.options` `a.constraints` `a_copy.options` a_copy.constraints`.  Zum Beispiel kann `a.options` den Inhalt von Sektion 2 enthalten und `a_copy.options` die Variante:
      ```
      Bildschirm,8,2,1,4
      RAM,6,5,7
      Prozessor,Intel,AMD
      ```
     Die Reihenfolge kann natürlich auch die selbe bleiben. 
     Geben Sie einfach die Optionen und Werte so aus wie es am einfachsten im Code ist (aber: die Option muss natürlich am Anfang stehen).


Projekt:


Aufgabe 2: 
   Lösen Sie das Problem, indem Sie die `.models-Datei` ausgeben.

Aufgabe 3A (Checker (Variante A)):
   Implementieren Sie einen Checker.

Aufgabe 3B (Fuzzer (Variante B)):
   Implementieren Sie einen Fuzzer.
   Sie dürfen das Bash-Skript nutzen, das mit dem `crippled-fuzzer` mitgeliefert wird. 
   Es ruft das Fuzzer auf und ruft dann Ihr Programm auf, bis ein Fehler gefunden wurde.
   Bevor Sie abgeben, stellen Sie sich er, dass:
      1. es ein kurzes Readme gibt, damit Ihr Tutor auch weiß, wo er anfangen soll zu lesen,
      2. Sie auch ein Beispiel in der Readme haben, wie alles aufgerufen wird, und
      3. es in der Erfahrungsdatei (weit oben) auch genau steht, was Sie implementiert haben (also 3A oder 3B).


      In the following, some examples: 
    Here is a.constraints:
    <pre><code>
      Prozessor,AMD,RAM,6
      Prozessor,AMD,RAM,7
      Prozessor,Intel,RAM,5,Bildschirm,8
    </code></pre>
    Here is a.models:
    <pre><code>
    Prozessor,Intel,RAM,7,Bildschirm,2
    RAM,6,Prozessor,Intel,Bildschirm,1
    Prozessor,Intel,RAM,5,Bildschirm,2
    Prozessor,AMD,RAM,5,Bildschirm,1
    Prozessor,AMD,RAM,5,Bildschirm,8
    Prozessor,Intel,RAM,5,Bildschirm,4
    RAM,6,Prozessor,Intel,Bildschirm,8
    </code></pre>
    Here is a.options:
    <pre><code>
    Prozessor,Intel,AMD
    RAM,5,6,7
    Bildschirm,1,2,4,8
    </code></pre>
    Here is a2.options:
    <pre><code>
    Prozessor,Intel,AMD
    RAM,5,6,7
    Bildschirm,8,1,2,4</code></pre>

    </pre>


    Here is Makefile:
    <pre>
            <code>
              CXX = g++
                CXXFLAGS=  --std=c++14 #-Wextra -Wall -pedantic
                EXCLUDED = poly2.cpp
                HEADERS = $(filter-out $(EXCLUDED), $(wildcard *.hpp))
                OBJECTS = $(addsuffix .o, $(basename  $(filter-out $(EXCLUDED) %Test.cpp %Main.cpp, $(wildcard *.cpp))))
                TESTLIBS = -lgtest -lgtest_main -lpthread
                TEST_BINARIES = $(basename $(wildcard *[Tt]est.cpp))
                
                all: clean compile
                
                %.o: %.cpp $(HEADERS)
                    $(CXX) $(CXXFLAGS) -c $<
                
                %Main: %Main.cpp $(OBJECTS)
                    $(CXX) $(CXXFLAGS) -o $@ $^
                
                compile: bddMain nqueensMain
                
                %Test: %Test.o $(OBJECTS)
                    $(CXX) $(CXXFLAGS) -o $@ $^ $(LIBS)  $(TESTLIBS)
                
                test: $(TEST_BINARIES)
                    echo "$(TESTS)"
                    for test in `ls *Test` ; \
                    do \
                    ./$$test || (echo "failed test $$test" && exit 255) \
                    done
                
                clean:
                    rm -f *Main *Test *.o
                
                format:
                    clang-format -i *.cpp *.hpp         
            
                
            </code>
        </pre>
  </main>

  <footer>
  </footer>
  <script type="text/javascript">
    $(function () {
      $('header a.icon').click(function () {
        $('nav').toggleClass('responsive');
      });
    });
  </script>
</body>

</html>